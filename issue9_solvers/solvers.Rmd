---
title: "Solvers"
output: github_document
date: "2023-01-28"
---

## Overview

In this document we explore the behavior of two solvers for the smoothest path problem.

- `Rsolnp`: General Non-linear Optimization Using Augmented Lagrange Multiplier Method. Vignette [here](https://cran.r-project.org/web/packages/Rsolnp/Rsolnp.pdf).


- `nloptr`: Solve optimization problems using an R interface to open-source NLopt. Vignette [here](https://cran.r-project.org/web/packages/nloptr/nloptr.pdf). Useful pdf with explainers [here](https://arxiv.org/pdf/2101.02912.pdf).

## Loading packages

```{r setup, warning = F, message = F}
# Load package
library(devtools)

setwd("..")
load_all()
setwd("issue9_solvers")

# Load solvers
library(nloptr)
library(Rsolnp)

# Load other
library(data.table)  # Data manipulation
library(ggplot2)     # Plotting
library(knitr)       # Priting nice tables
library(pracma)      # Matrix inverses
```

## Data

We use the sample data of the package, specifically the one where the y variable jumps.

```{r load data}
dt <- fread("data_jump.csv")
kable(dt[, .(term, label, estimate, std.error)])
```

We also load the covariance data. We show only the first 7 rows and columns below.

```{r load covar}
covar <- read.csv("covar.csv", row.names = 1)
dim(covar)
kable(covar[1:7,1:7])
```

## Find order of polynomial

We find the minimum order such that a polynomial is in the Wald region of the coefficients.
We use a function already incorporated in the package.

```{r}
coefficients <- dt$estimate

covar     <- data.matrix(covar)
inv_covar <- pracma::pinv(covar)

Wcritic   <- qchisq(.95, length(coefficients))

Sol1 <- FindOrder(coefficients, inv_covar, Wcritic, maxorder = 10)

order <- Sol1$order
poly_coeffs <- Sol1$results$vhat
poly_path   <- Sol1$results$trfit
```

The resulting order is `r order`.

A plot of the resulting path is below. This is _not_ the smoothest path.

```{r plot, fig.align='center', fig.width=6, fig.height=4}
dt[, poly_path := poly_path]
dt[, label := factor(label, levels = dt$label)]

ggplot(dt, aes(x = label)) +
    geom_point(aes(y = estimate), size = 2) +
    geom_errorbar(aes(ymin = estimate - 1.96*std.error,
                      ymax = estimate + 1.96*std.error),
                  width = 0.2) +
    geom_point(aes(y = poly_path), size = 2, color = "red")
```

## Searching for the smoothest path

Now that we now the order of the desired polynomial, we want to find the smoothest path by solving the following problem:

1. Choose coefficients for the desired order to minimize the squared of the coefficient on the highest order polynomial term.
2. Constraint the minimization to paths inside the Wald confidence region.
3. Constraint the minimization to paths where the normalized coefficients are zero.

### Solver `Rsolnp`


We define the functions we use to implement this problem below.

```{r functions}

Objective <- function(v, d, invV) {
  p = length(v)
  return(v[p]^2)
}

IneqConstraint <- function(v, d, invV) {
  p <- length(v)
  r <- length(d)

  k    = seq(0, r-1)/(r-1)
  Fmat = sapply(seq(1, p),
                   function(j) {k^(j-1)})
  trfit <- Fmat %*% v

  W     <- (t(d-trfit)%*%invV)%*%(d-trfit)
  return(W)
}

EqConstraint <- function(v, d, invV) {

  norm_index <- which(d == 0)
    
  p <- length(v)
  r <- length(d)

  k    = seq(0, r-1)/(r-1)
  Fmat = sapply(seq(1, p),
                   function(j) {k^(j-1)})
  trfit <- Fmat %*% v

  norm_sm_path <- trfit[norm_index]

  return(norm_sm_path)
}
```

Next, we run the solver.

```{r solve Rsolnp}
norm_idxs <- which(coefficients == 0)

optim <- solnp(pars      = rep(0, order),
               fun       = Objective,
               eqfun     = EqConstraint,
               eqB       = rep(0, length(norm_idxs)),
               ineqfun   = IneqConstraint,
               ineqUB    = Wcritic,
               ineqLB    = -Inf,
               d         = coefficients,
               invV      = inv_covar)
```

We obtain the error "Problem inverting Hessian". Can we invert the hessian manually?

```{r}
pinv(optim$hessian) # Pseudo-inverse
inv(optim$hessian)  # Inverse
```


### Solver `nloptr`

We define the functions we use to implement this problem below.
We changed them a bit because we need to rewrite the inequality constraint
as $W(v)-W_{critic}\leq 0$, when before we could do $W(v)\leq W_{critic}$

```{r functions nloptr}

Objective <- function(v, d, invV, Wcritic) {
  p = length(v)
  return(v[p]^2)
}

IneqConstraint <- function(v, d, invV, Wcritic) {
  p <- length(v)
  r <- length(d)

  k    = seq(0, r-1)/(r-1)
  Fmat = sapply(seq(1, p),
                   function(j) {k^(j-1)})
  trfit <- Fmat %*% v

  W     <- (t(d-trfit)%*%invV)%*%(d-trfit)
  return(W - Wcritic)
}

EqConstraint <- function(v, d, invV, Wcritic) {

  norm_index <- which(d == 0)
    
  p <- length(v)
  r <- length(d)

  k    = seq(0, r-1)/(r-1)
  Fmat = sapply(seq(1, p),
                   function(j) {k^(j-1)})
  trfit <- Fmat %*% v

  norm_sm_path <- trfit[norm_index]

  return(norm_sm_path)
}
```

Next, we run the solver.
It appears that, for some reason, the initial guess of $(0,..,0)$ does not change.
The solver, however, works in a simpler example with the options.
(See file [`test_nloptr.R`](test_nloptr.R))

```{r solve nloptr}
local_opts <- list( "algorithm" = "NLOPT_LD_MMA", "xtol_rel" = 1.0e-8)
opts <- list("algorithm"   = "NLOPT_GN_ISRES",
             "xtol_rel"    = 1.0e-10,
             "maxeval"     = 100*1e3,
              "local_opts" = local_opts,
             "print_level" = 0)

# Bounds on vector of coefficients (for some reason they are required)
lb_ <- sapply(1:order, function(j) {-(100^j)})
ub_ <- sapply(1:order, function(j) {(100^j)})

res <- nloptr ( x0 = rep(0, order),
                eval_f = Objective,      # Objective function
                lb = lb_, ub = ub_,
                eval_g_ineq = IneqConstraint,  # Ineq constraint <= 0
                eval_g_eq = EqConstraint,      # Eq contraint    = 0
                opts = opts,
                d = coefficients, invV = inv_covar, Wcritic = Wcritic)
print(res)
```


